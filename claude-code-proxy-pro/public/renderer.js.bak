// æ¸²æŸ“è¿›ç¨‹è„šæœ¬
const { electronAPI } = window;

// DOMå…ƒç´ 
const elements = {
    version: document.getElementById('version'),
    globalStatus: document.getElementById('globalStatus'),
    environmentList: document.getElementById('environmentList'),
    checkEnvBtn: document.getElementById('checkEnvBtn'),
    apiKey: document.getElementById('apiKey'),
    proxyUrl: document.getElementById('proxyUrl'),
    toggleApiKey: document.getElementById('toggleApiKey'),
    saveEnvBtn: document.getElementById('saveEnvBtn'),
    testEnvBtn: document.getElementById('testEnvBtn'),
    toast: document.getElementById('toast')
};

// çŠ¶æ€ç®¡ç†
const state = {
    environments: {},
    isOnline: false,
    apiKeyVisible: false
};

// Toastæç¤º
function showToast(message, type = 'info') {
    const toast = elements.toast;
    toast.textContent = message;
    toast.className = `toast show ${type}`;
    
    setTimeout(() => {
        toast.classList.remove('show');
    }, 3000);
}

// æ›´æ–°å…¨å±€çŠ¶æ€
function updateGlobalStatus(isOnline) {
    state.isOnline = isOnline;
    const statusEl = elements.globalStatus;
    
    if (isOnline) {
        statusEl.classList.add('online');
        statusEl.querySelector('.status-text').textContent = 'åœ¨çº¿';
    } else {
        statusEl.classList.remove('online');
        statusEl.querySelector('.status-text').textContent = 'ç¦»çº¿';
    }
}

// æ¸²æŸ“ç¯å¢ƒåˆ—è¡¨
function renderEnvironments(environments) {
    state.environments = environments;
    const list = elements.environmentList;
    
    if (!environments || Object.keys(environments).length === 0) {
        list.innerHTML = '<div class="env-item"><span class="env-status not-installed">æš‚æ— ç¯å¢ƒä¿¡æ¯ï¼Œè¯·ç‚¹å‡»æ£€æµ‹æŒ‰é’®</span></div>';
        return;
    }
    
    const html = Object.entries(environments).map(([key, env]) => {
        const isInstalled = env.status === 'installed';
        const statusClass = isInstalled ? 'installed' : 'not-installed';
        const statusIcon = isInstalled ? 'âœ“' : 'â—‹';
        const statusText = isInstalled ? `å·²å®‰è£… v${env.version}` : 'æœªå®‰è£…';
        
        return `
            <div class="env-item">
                <div class="env-info">
                    <div class="env-name">${env.name}</div>
                    <div class="env-status ${statusClass}">
                        <span>${statusIcon}</span>
                        <span>${statusText}</span>
                    </div>
                </div>
                ${!isInstalled ? `<button class="install-btn" data-env="${key}">å®‰è£…</button>` : ''}
            </div>
        `;
    }).join('');
    
    list.innerHTML = html;
    
    // ç»‘å®šå®‰è£…æŒ‰é’®äº‹ä»¶
    list.querySelectorAll('.install-btn').forEach(btn => {
        btn.addEventListener('click', handleInstallEnvironment);
    });
}

// æ£€æµ‹ç¯å¢ƒ
async function checkEnvironments() {
    const btn = elements.checkEnvBtn;
    btn.disabled = true;
    btn.innerHTML = '<span class="loading"></span> æ£€æµ‹ä¸­...';
    
    try {
        const environments = await electronAPI.checkEnvironments();
        renderEnvironments(environments);
        showToast('ç¯å¢ƒæ£€æµ‹å®Œæˆ', 'success');
    } catch (error) {
        showToast(`æ£€æµ‹å¤±è´¥: ${error.message}`, 'error');
    } finally {
        btn.disabled = false;
        btn.innerHTML = '<span class="btn-icon">ğŸ”</span> æ£€æµ‹ç³»ç»Ÿç¯å¢ƒ';
    }
}

// å®‰è£…ç¯å¢ƒ
async function handleInstallEnvironment(event) {
    const envKey = event.target.dataset.env;
    const env = state.environments[envKey];
    
    if (!confirm(`ç¡®å®šè¦å®‰è£… ${env.name} å—ï¼Ÿ`)) return;
    
    const btn = event.target;
    btn.disabled = true;
    btn.textContent = 'å®‰è£…ä¸­...';
    
    try {
        const result = await electronAPI.installEnvironment(envKey);
        showToast(result.message, 'success');
        // é‡æ–°æ£€æµ‹ç¯å¢ƒ
        await checkEnvironments();
    } catch (error) {
        showToast(`å®‰è£…å¤±è´¥: ${error.message}`, 'error');
        btn.disabled = false;
        btn.textContent = 'å®‰è£…';
    }
}

// åˆ‡æ¢APIå¯†é’¥å¯è§æ€§
function toggleApiKeyVisibility() {
    state.apiKeyVisible = !state.apiKeyVisible;
    elements.apiKey.type = state.apiKeyVisible ? 'text' : 'password';
    
    const icon = elements.toggleApiKey.querySelector('svg');
    if (state.apiKeyVisible) {
        icon.innerHTML = `
            <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
            <line x1="1" y1="1" x2="23" y2="23"></line>
        `;
    } else {
        icon.innerHTML = `
            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
            <circle cx="12" cy="12" r="3"></circle>
        `;
    }
}

// ä¿å­˜ç¯å¢ƒå˜é‡
async function saveEnvironmentVariables() {
    const apiKey = elements.apiKey.value.trim();
    const proxyUrl = elements.proxyUrl.value.trim();
    
    if (!apiKey) {
        showToast('è¯·è¾“å…¥APIå¯†é’¥', 'error');
        return;
    }
    
    const btn = elements.saveEnvBtn;
    btn.disabled = true;
    btn.innerHTML = '<span class="loading"></span> ä¿å­˜ä¸­...';
    
    try {
        await electronAPI.saveConfig({ apiKey, proxyUrl });
        showToast('è®¾ç½®å·²ä¿å­˜', 'success');
        updateGlobalStatus(true);
    } catch (error) {
        showToast(`ä¿å­˜å¤±è´¥: ${error.message}`, 'error');
    } finally {
        btn.disabled = false;
        btn.innerHTML = '<span class="btn-icon">ğŸ’¾</span> ä¿å­˜è®¾ç½®';
    }
}

// æµ‹è¯•è¿æ¥
async function testConnection() {
    const btn = elements.testEnvBtn;
    btn.disabled = true;
    btn.innerHTML = '<span class="loading"></span> æµ‹è¯•ä¸­...';
    
    try {
        // TODO: å®ç°å®é™…çš„è¿æ¥æµ‹è¯•
        await new Promise(resolve => setTimeout(resolve, 1500));
        showToast('è¿æ¥æµ‹è¯•æˆåŠŸ', 'success');
        updateGlobalStatus(true);
    } catch (error) {
        showToast(`è¿æ¥å¤±è´¥: ${error.message}`, 'error');
        updateGlobalStatus(false);
    } finally {
        btn.disabled = false;
        btn.innerHTML = '<span class="btn-icon">ğŸ§ª</span> æµ‹è¯•è¿æ¥';
    }
}

// åˆå§‹åŒ–
async function init() {
    try {
        // æ˜¾ç¤ºç‰ˆæœ¬å·
        const version = await electronAPI.getAppVersion();
        elements.version.textContent = `v${version}`;
        
        // åŠ è½½é…ç½®
        const config = await electronAPI.getConfig();
        if (config.apiKey) {
            elements.apiKey.value = config.apiKey;
            updateGlobalStatus(true);
        }
        if (config.proxyUrl) {
            elements.proxyUrl.value = config.proxyUrl;
        }
        
        // è‡ªåŠ¨æ£€æµ‹ç¯å¢ƒ
        await checkEnvironments();
    } catch (error) {
        console.error('åˆå§‹åŒ–å¤±è´¥:', error);
        showToast('åˆå§‹åŒ–å¤±è´¥', 'error');
    }
}

// äº‹ä»¶ç»‘å®š
elements.checkEnvBtn.addEventListener('click', checkEnvironments);
elements.toggleApiKey.addEventListener('click', toggleApiKeyVisibility);
elements.saveEnvBtn.addEventListener('click', saveEnvironmentVariables);
elements.testEnvBtn.addEventListener('click', testConnection);

// å¯åŠ¨åº”ç”¨
init();